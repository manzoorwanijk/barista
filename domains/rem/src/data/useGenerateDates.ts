import { sortBy, prop } from 'ramda';
import { RRule, RRuleSet } from 'rrule';
import { formatISO, parseISO } from 'date-fns';

import { useMemoStringify } from '@eventespresso/hooks';
import useFormState from './useFormState';
import { getDatesLimit } from '../utils';
import type { GeneratedDate } from '../ui/generatedDates/types';

/**
 * This pattern is used to replace COUNT in rrule to generate 500 dates
 * to make sure enough dates are generated to be able to remove dates generated by exRule
 *
 * We could use positive lookaround zero-length assertions like
 * const COUNT_REGEX = /(?<=COUNT=)[0-9]+?(?=;)/; and then simply write
 * const COUNT_REPLACE = '500';
 * but lookbehinds in JavaScript are not supported by all browsers yet (at the time of writing)
 * and Babel cannot transform them ¯\_(ツ)_/¯
 * @link https://www.regular-expressions.info/javascript.html
 */
const COUNT_REGEX = /COUNT=[0-9]+?;/; // matches "COUNT=8;", "COUNT=50;", "COUNT=102;" etc.
const COUNT_REPLACE = 'COUNT=500;';

export const useGenerateDates = (includeExDates?: boolean): Array<GeneratedDate> => {
	const { exRule, rRule, exDates, rDates } = useFormState();

	let result: Array<GeneratedDate> = [];

	if (rRule) {
		const rruleSet = new RRuleSet();

		// set COUNT to a higher value to generate plenty of dates
		const extendedRRule = rRule.replace(COUNT_REGEX, COUNT_REPLACE);

		rruleSet.rrule(RRule.fromString(extendedRRule));

		if (exRule) {
			rruleSet.exrule(RRule.fromString(exRule));
		}

		rDates.forEach((rDate) => {
			rruleSet.rdate(parseISO(rDate));
		});

		exDates.forEach((exDate) => {
			rruleSet.exdate(parseISO(exDate));
		});

		// We need to adjust the number of rDates and exDates in total dates generated
		// to avoid they being excluded from total count
		const datesLimit = getDatesLimit(rRule) - exDates.length + rDates.length;

		const rruleGeneratedDates = rruleSet.all((date, i) => {
			return i < datesLimit;
		});

		let generatedDates: Array<GeneratedDate> = rruleGeneratedDates.map<GeneratedDate>((date) => {
			const ISOStr = formatISO(date);
			const type = rDates.includes(ISOStr) ? 'rDate' : 'gDate';

			return { date, ISOStr, type };
		});

		if (includeExDates) {
			const excludedDates: Array<GeneratedDate> = exDates.map<GeneratedDate>((dateStr) => {
				const date = parseISO(dateStr);
				const type = 'exDate';

				return { date, ISOStr: dateStr, type };
			});
			generatedDates = [...generatedDates, ...excludedDates];
		}

		result = sortBy(prop('ISOStr'), generatedDates);
	}

	return useMemoStringify(result);
};

export default useGenerateDates;
